{"meta":{"title":"ZJC","subtitle":"Stay Hungry, Stay Foolish","description":"Zhangjicheng个人站，主要涉及前端知识共享、实践教程、前沿技术共同学习等方面","author":"zhang jicheng","url":"https://zhangjichengcc.github.io"},"pages":[{"title":"","date":"2018-12-04T02:05:32.151Z","updated":"2018-12-04T02:05:32.151Z","comments":true,"path":"about/index.html","permalink":"https://zhangjichengcc.github.io/about/index.html","excerpt":"","text":".about { box-sizing: border-box; padding-top: 20px; } .about_head>.about_head_left { display: inline-block; width: 200px; padding: 10px; } .about_head>.about_head_right { float: right; display: inline-block; width: 100%; padding: 10px; padding-left: 200px; } .about_head>.about_head_left>.about_head_left_img { background-color: #0ff; height: 300px; box-shadow: 12px 12px 0px 0px rgba(0,0,0,0.1); } function haha(){ alert('asdsfasf'); }"},{"title":"About","date":"2018-09-26T10:22:02.000Z","updated":"2018-12-03T02:27:15.561Z","comments":true,"path":"about/index.html","permalink":"https://zhangjichengcc.github.io/about/index.html","excerpt":"","text":".aa { color: #0f0; } adfafafd asdfasdfasfdafd 友情链接ECMAScript 6 入门： http://es6.ruanyifeng.com/杨某的博客： https://angusyang9.github.io/刘某某的博客： https://provenr.github.io/"},{"title":"标签","date":"2018-09-27T06:31:12.000Z","updated":"2018-09-27T10:01:14.759Z","comments":true,"path":"tags/index.html","permalink":"https://zhangjichengcc.github.io/tags/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2018-09-27T06:23:33.000Z","updated":"2018-09-27T10:00:27.766Z","comments":true,"path":"categories/index.html","permalink":"https://zhangjichengcc.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"监听浏览器刷新及关闭6666","slug":"监听浏览器刷新及关闭","date":"2018-12-12T02:37:25.000Z","updated":"2018-12-13T07:41:14.308Z","comments":true,"path":"2018/12/12/监听浏览器刷新及关闭/","link":"","permalink":"https://zhangjichengcc.github.io/2018/12/12/监听浏览器刷新及关闭/","excerpt":"需求背景： 为保证‘高度安全性’，用户每次退出页面或浏览器都要清除登陆信息，每次进入系统都要重新登陆（每次登陆还要手机验证码等乱七八糟的验证信息，，，求用户的心里阴影面积），但是刷新页面不可以清除登陆信息。解决思路： javascript 对于浏览器的关闭和刷新会触发两个事件 onbeforeunload()和onunload()，问题在于如何区分用户是想刷新还是退出（此时应该将用户催眠，然后获得用户的思想，预判用户走位及操作。。。），本文主要记录这两个方法的区别，设备兼容性及如何催眠用户（开玩笑的），是如何区分刷新和退出浏览器","text":"需求背景： 为保证‘高度安全性’，用户每次退出页面或浏览器都要清除登陆信息，每次进入系统都要重新登陆（每次登陆还要手机验证码等乱七八糟的验证信息，，，求用户的心里阴影面积），但是刷新页面不可以清除登陆信息。解决思路： javascript 对于浏览器的关闭和刷新会触发两个事件 onbeforeunload()和onunload()，问题在于如何区分用户是想刷新还是退出（此时应该将用户催眠，然后获得用户的思想，预判用户走位及操作。。。），本文主要记录这两个方法的区别，设备兼容性及如何催眠用户（开玩笑的），是如何区分刷新和退出浏览器 onbeforeunload()和onunload() onbeforeunload 和 onunload 都是在页面刷新或退出时触发的事件 用法： 事件 用法 onunload window.onunload=function(){SomeJavaScriptCode}; onbeforeunload window.onbeforeunload=function(){SomeJavaScriptCode}; 区别： unbeforeunload()是在页面刷新或关闭之前触发的事件，而onubload()是在页面刷新或关闭之后才会触发的。 unbeforeunload()事件执行的顺序在onunload()事件之前发生。 unbeforeunload()事件可以禁止onunload()事件的触发。 onunload()事件是无法阻止页面关闭的。 兼容性（pc）： 事件 Chrome Firefox IE Opera Safari onunload yes&nbsp;&nbsp; yes&nbsp;&nbsp; yes&nbsp;&nbsp; yes&nbsp;&nbsp; yes onbeforeunload 1 1 4 12 3 onbeforeunoad 在移动端基本都不兼容，onunload则兼容大部分主流移动端浏览器 参考文献：MDN: window.onbeforeunloadMDN: window.onunload 区分刷新和退出 在浏览器关闭前是无法判断用户是刷新还是退出，所以我们在用户再次打开的时候来判断用户是否刷新 解决思路： 用户关闭浏览器时，记录当前时间，并存于浏览器缓存中 用户再次打开页面时，获取上次退出的时间，并于当前时间进行比较，若小于5s则表示用户执行的是刷新操作，若大于5s则判定为退出 注意： 5s并非固定，要根据实际情况调整 上代码： 123456789101112131415// 进入页面执行// 记录当前时间并转成时间戳const now = new Date().getTime();// 从缓存中获取用户上次退出的时间戳const leaveTime = parseInt(localStorage.getItem('leaveTime'), 10);// 判断是否为刷新，两次间隔在5s内判定为刷新操作const refresh = (now - leaveTime) &lt;= 5000;// 测试alertalert(refresh ? '刷新' : '重新登陆');// 退出当前页面执行window.onunload = function(e)&#123; // ios 不支持 window.onbeforeunload() // 将退出时间存于localstorage中 localStorage.setItem('leaveTime', new Date().getTime());&#125;","categories":[{"name":"随笔","slug":"随笔","permalink":"https://zhangjichengcc.github.io/categories/随笔/"}],"tags":[{"name":"js","slug":"js","permalink":"https://zhangjichengcc.github.io/tags/js/"},{"name":"前端","slug":"前端","permalink":"https://zhangjichengcc.github.io/tags/前端/"}]},{"title":"jenkins+github+hexo 部署个人博客","slug":"jenkins部署个人博客","date":"2018-12-08T07:26:12.000Z","updated":"2018-12-08T10:21:55.686Z","comments":true,"path":"2018/12/08/jenkins部署个人博客/","link":"","permalink":"https://zhangjichengcc.github.io/2018/12/08/jenkins部署个人博客/","excerpt":"Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。","text":"Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。 ###部署方式 jenkins的构建方式常用分为三种。 jenkins触发式构建：push代码或者合并代码到项目的master或者其他分支，jenkins就部署代码到对应服务器。 jenkins参数化构建：push代码或者合并代码到项目的master或者其他分支之后，并不会部署代码，而是需要登录到jenkins的web界面，点击构建按钮，传入对应的参数（比如参数需要构建的tag，需要部署的分支）然后才会部署。 jenkins定时构建：多用于APP、自动化用例等自动打包，定时构建是在参数化构建的基础上添加的，开发人员可以登录jenkins手动传入tag进行打包，如果不手动打包，那么jenkins就定时从配置项目地址拉取最新的代码打包。 安装java环境下载JDK首先我们需要下载java开发工具包JDK，下载地址：http://www.oracle.com/technetwork/java/javase/downloads/index.html，下载对应版本：下载后JDK的安装根据提示进行，还有安装JDK的时候也会安装JRE，一并安装就可以了。 配置环境变量1.安装完成后，右击”我的电脑”，点击”属性”，选择”高级系统设置”；2.选择”高级”选项卡，点击”环境变量”；3.添加环境变量在”系统变量”中设置3项属性，JAVA_HOME,PATH,CLASSPATH(大小写无所谓),若已存在则点击”编辑”，不存在则点击”新建”。 变量设置参数如下： 变量名 变量值 JAVA_HOME C:\\Program Files (x86)\\Java\\jdk1.8.0_91 // 要根据自己的实际路径配置 CLASSPATH .;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; Path %JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin; 测试JDK是否安装成功进入cmd，键入命令: java -version、java、javac 几个命令进行验证 jenkins安装jenkins配置安装完成后，访问 http://你的服务器ip:8080/ 即可 安装好 Jenkins 后，第一次访问会让你输入密码，页面上会提示具体是哪个文件，用 vim 打开即可查看，比如 CentOS 默认是：/var/lib/jenkins/secrets/initialAdminPassword。 进入后，可以创建新的用户，以后就可以使用这个用户访问 Jenkins 了。 新建账号后，会提示安装插件，一般直接按推荐安装，如果有报错，最好点击重试，多试几次一般都会安装成功，如果实在装不上那就先跳过吧 新建任务，输入任务名，选择自由风格即可：新建任务，输入任务名，选择自由风格即可：选择github项目，项目url填写自己博客页面的url","categories":[{"name":"随笔","slug":"随笔","permalink":"https://zhangjichengcc.github.io/categories/随笔/"}],"tags":[{"name":"js","slug":"js","permalink":"https://zhangjichengcc.github.io/tags/js/"},{"name":"前端","slug":"前端","permalink":"https://zhangjichengcc.github.io/tags/前端/"},{"name":"部署","slug":"部署","permalink":"https://zhangjichengcc.github.io/tags/部署/"},{"name":"jenkins","slug":"jenkins","permalink":"https://zhangjichengcc.github.io/tags/jenkins/"}]},{"title":"HTTP状态码和AJAX状态值hexo44","slug":"HTTP状态码和AJAX状态值","date":"2018-11-29T07:01:52.000Z","updated":"2018-12-08T06:13:57.516Z","comments":true,"path":"2018/11/29/HTTP状态码和AJAX状态值/","link":"","permalink":"https://zhangjichengcc.github.io/2018/11/29/HTTP状态码和AJAX状态值/","excerpt":"超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。Ted Nelson组织协调万维网协会（World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force ）共同合作研究，最终发布了一系列的RFC，其中著名的RFC 2616定义了HTTP 1.1。","text":"超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。Ted Nelson组织协调万维网协会（World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force ）共同合作研究，最终发布了一系列的RFC，其中著名的RFC 2616定义了HTTP 1.1。 HTTP 超文本传输协议 HTTP 是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。&nbsp;一个HTTP “客户端”是一个应用程序（Web浏览器或其他任何客户端），通过连接到服务器达到向服务器发送一个或多个HTTP的请求的目的。一个HTTP “服务器”同样也是一个应用程序（通常是一个Web服务，如Apache Web服务器或IIS服务器等），通过接收客户端的请求并向客户端发送HTTP响应数据。&nbsp;HTTP 使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。HTTP 请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。&nbsp;HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。HTTP1.1 新增了五种请求方法： OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 HTTP 请求方式 请求方式 请求中文说明 GET 请求指定的页面信息，并返回实体主体。 HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE 请求服务器删除指定的页面。 CONNECT&nbsp;&nbsp;&nbsp;&nbsp; HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS 允许客户端查看服务器的性能。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 AJAX 状态值 与 HTTP状态码AJAX状态值与状态码区别 AJAX状态值是指，运行AJAX所经历过的几种状态，无论访问是否成功都将响应的步骤，可以理解成为AJAX运行步骤。如：正在发送，正在响应等，由AJAX对象与服务器交互时所得；使用ajax.readyState获得。 AJAX状态码是指，无论AJAX访问是否成功，由HTTP协议根据所提交的信息，服务器所返回的HTTP头信息代码，该信息使用ajax.status所获得。 这就是我们在使用AJAX时为什么采用下面的方式判断所获得的信息是否正确的原因。123if( ajax.readyState == 4 &amp;&amp; ajax.status == 200 ) &#123; // do success&#125; AJAX状态值 在《Pragmatic Ajax A Web 2.0 Primer 》&nbsp; 0: (Uninitialized) the send( ) method has not yet been invoked.1: (Loading) the send( ) method has been invoked, request in progress.2: (Loaded) the send( ) method has completed, entire response received.3: (Interactive) the response is being parsed.4: (Completed) the response has been parsed, is ready for harvesting.&nbsp;0 － （未初始化）还没有调用send()方法1 － （载入）已调用send()方法，正在发送请求2 － （载入完成）send()方法执行完成，已经接收到全部响应内容3 － （交互）正在解析响应内容4 － （完成）响应内容解析完成，可以在客户端调用了 HTTP 状态码 当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。HTTP状态码的英文为HTTP Status Code。 下面是常见的HTTP状态码： 码值 描述 200 请求成功 301 资源（网页等）被永久转移到其它URL 404 请求的资源（网页等）不存在 500 内部服务器错误 HTTP状态码分类 HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型： 分类 描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 HTTP状态码列表 HTTP状态码列表: 码值 英文名称 中文描述 100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Continue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 继续。客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 200 OK 请求成功。一般用于GET与POST请求 201 Created 已创建。成功请求并创建了新的资源 202 Accepted 已接受。已经接受请求，但未处理完成 203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 206 Partial Content 部分内容。服务器成功处理了部分GET请求 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 303 See Other 查看其它地址。与301类似。使用GET和POST请求查看 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 305 Use Proxy 使用代理。所请求的资源必须通过代理访问 306 Unused 已经被废弃的HTTP状态码 307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向 400 Bad Request 客户端请求的语法错误，服务器无法理解 401 Unauthorized 请求要求用户的身份认证 402 Payment Required 保留，将来使用 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面 405 Method Not Allowed 客户端请求中的方法被禁止 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求 407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 408 Request Time-out 服务器等待客户端发送的请求时间过长，超时 409 Conflict 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突 410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息 412 Precondition Failed 客户端请求信息的先决条件错误 413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 416 Requested range not satisfiable 客户端请求的范围无效 417 Expectation Failed 服务器无法满足Expect的请求头信息 500 Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhangjichengcc.github.io/categories/笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"https://zhangjichengcc.github.io/tags/js/"},{"name":"前端","slug":"前端","permalink":"https://zhangjichengcc.github.io/tags/前端/"}]},{"title":"ES6 async","slug":"async","date":"2018-10-10T09:18:18.000Z","updated":"2018-11-28T01:17:30.580Z","comments":true,"path":"2018/10/10/async/","link":"","permalink":"https://zhangjichengcc.github.io/2018/10/10/async/","excerpt":"ES2017 标准引入了 async 函数，使得异步操作变得更加方便。","text":"ES2017 标准引入了 async 函数，使得异步操作变得更加方便。 含义 async 函数是什么？一句话，它就是 Generator 函数的语法糖。 现在有一个 Generator 函数，依次读取两个文件。 12345678910const fs = require('fs');const readFile = function (fileName) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(fileName, function(error, data) &#123; if (error) return reject(error); resolve(data); &#125;); &#125;);&#125;; 123456const gen = function* () &#123; const f1 = yield readFile('/etc/fstab'); const f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 写成async函数，就是下面这样。 123456const asyncReadFile = async function () &#123; const f1 = await readFile('/etc/fstab'); const f2 = await readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。 async函数对 Generator 函数的改进，体现在以下四点。 1）内置执行器。 Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。 2）更好的语义。 async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。 3）更广的适用性。 co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。 4）返回值是 Promise。 async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。 进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。 基本用法 async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 123456789async function getStockPriceByName(name) &#123; const symbol = await getStockSymbol(name); const stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName('goog').then(function (result) &#123; console.log(result);&#125;); 上面代码是一个获取股票报价的函数，函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。 下面是另一个例子，指定多少毫秒后输出一个值。 123456789101112function timeout(ms) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint('hello world', 50); 上面代码指定 50 毫秒以后，输出hello world。 由于async函数返回的是 Promise 对象，可以作为await命令的参数。所以，上面的例子也可以写成下面的形式。 123456789101112async function timeout(ms) &#123; await new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint('hello world', 50); 返回 Promise 对象 async函数返回一个 Promise 对象。async函数内部return语句返回的值，会成为then方法回调函数的参数。 12345678910111213141516171819async function f() &#123; return 'hello world';&#125;f().then(v =&gt; console.log(v))// \"hello world\"上面代码中，函数f内部`return`命令返回的值，会被then方法回调函数接收到。`async`函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。async function f() &#123; throw new Error('出错了');&#125;f().then( v =&gt; console.log(v), e =&gt; console.log(e))// Error: 出错了 Promise 对象的状态变化 async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。 下面是一个例子。 1234567async function getTitle(url) &#123; let response = await fetch(url); let html = await response.text(); return html.match(/&lt;title&gt;([\\s\\S]+)&lt;\\/title&gt;/i)[1];&#125;getTitle('https://tc39.github.io/ecma262/').then(console.log)// \"ECMAScript 2017 Language Specification\" 上面代码中，函数getTitle内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行then方法里面的console.log。 await 命令正常情况下，await命令后面是一个 Promise 对象。如果不是，就返回对应的值。 12345678async function f() &#123; // 等同于 // return 123; return await 123;&#125;f().then(v =&gt; console.log(v))// 123 上面代码中，await命令的参数是数值123，这时等同于return 123。 await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。 12345678async function f() &#123; await Promise.reject('出错了');&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))// 出错了 注意，上面代码中，await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数。这里如果在await前面加上return，效果是一样的。 只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行。 1234async function f() &#123; await Promise.reject('出错了'); await Promise.resolve('hello world'); // 不会执行&#125; 上面代码中，第二个await语句是不会执行的，因为第一个await语句状态变成了reject。 有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try...catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。 1234567891011async function f() &#123; try &#123; await Promise.reject('出错了'); &#125; catch(e) &#123; &#125; return await Promise.resolve('hello world');&#125;f().then(v =&gt; console.log(v))// hello world 另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。 12345678910async function f() &#123; await Promise.reject('出错了') .catch(e =&gt; console.log(e)); return await Promise.resolve('hello world');&#125;f().then(v =&gt; console.log(v))// 出错了// hello world 错误处理如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。 12345678910async function f() &#123; await new Promise(function (resolve, reject) &#123; throw new Error('出错了'); &#125;);&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))// Error：出错了 上面代码中，async函数f执行后，await后面的 Promise 对象会抛出一个错误对象，导致catch方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制。 防止出错的方法，也是将其放在try...catch代码块之中。 123456789async function f() &#123; try &#123; await new Promise(function (resolve, reject) &#123; throw new Error('出错了'); &#125;); &#125; catch(e) &#123; &#125; return await('hello world');&#125; 如果有多个await命令，可以统一放在try...catch结构中。 123456789101112async function main() &#123; try &#123; const val1 = await firstStep(); const val2 = await secondStep(val1); const val3 = await thirdStep(val1, val2); console.log('Final: ', val3); &#125; catch (err) &#123; console.error(err); &#125;&#125; 下面的例子使用try...catch结构，实现多次重复尝试。 123456789101112131415const superagent = require('superagent');const NUM_RETRIES = 3;async function test() &#123; let i; for (i = 0; i &lt; NUM_RETRIES; ++i) &#123; try &#123; await superagent.get('http://google.com/this-throws-an-error'); break; &#125; catch(err) &#123;&#125; &#125; console.log(i); // 3&#125;test(); 上面代码中，如果await操作成功，就会使用break语句退出循环；如果失败，会被catch语句捕捉，然后进入下一轮循环。 使用注意点第一点，前面已经说过，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch代码块中。 12345678910111213141516async function myFunction() &#123; try &#123; await somethingThatReturnsAPromise(); &#125; catch (err) &#123; console.log(err); &#125;&#125;// 另一种写法async function myFunction() &#123; await somethingThatReturnsAPromise() .catch(function (err) &#123; console.log(err); &#125;);&#125; 第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。 123456789101112let foo = await getFoo();let bar = await getBar();上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。// 写法一let [foo, bar] = await Promise.all([getFoo(), getBar()]);// 写法二let fooPromise = getFoo();let barPromise = getBar();let foo = await fooPromise;let bar = await barPromise; 上面两种写法，getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。 第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。 12345678async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; // 报错 docs.forEach(function (doc) &#123; await db.post(doc); &#125;);&#125; 上面代码会报错，因为await用在普通函数之中了。但是，如果将forEach方法的参数改成async函数，也有问题。 12345678function dbFuc(db) &#123; //这里不需要 async let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; // 可能得到错误结果 docs.forEach(async function (doc) &#123; await db.post(doc); &#125;);&#125; 上面代码可能不会正常工作，原因是这时三个db.post操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。 1234567async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; for (let doc of docs) &#123; await db.post(doc); &#125;&#125; 如果确实希望多个请求并发执行，可以使用Promise.all方法。当三个请求都会resolved时，下面两种写法效果相同。 1234567891011121314151617181920async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; let promises = docs.map((doc) =&gt; db.post(doc)); let results = await Promise.all(promises); console.log(results);&#125;// 或者使用下面的写法async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; let promises = docs.map((doc) =&gt; db.post(doc)); let results = []; for (let promise of promises) &#123; results.push(await promise); &#125; console.log(results);&#125; 目前，esm模块加载器支持顶层await，即await命令可以不放在 async 函数里面，直接使用。 1234567891011// async 函数的写法const start = async () =&gt; &#123; const res = await fetch('google.com'); return res.text();&#125;;start().then(console.log);// 顶层 await 的写法const res = await fetch('google.com');console.log(await res.text()); 上面代码中，第二种写法的脚本必须使用esm加载器，才会生效。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhangjichengcc.github.io/categories/笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"https://zhangjichengcc.github.io/tags/js/"},{"name":"ES6","slug":"ES6","permalink":"https://zhangjichengcc.github.io/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"https://zhangjichengcc.github.io/tags/前端/"}]},{"title":"ES6 Generator","slug":"Generator","date":"2018-10-10T08:00:37.000Z","updated":"2018-10-10T09:57:24.772Z","comments":true,"path":"2018/10/10/Generator/","link":"","permalink":"https://zhangjichengcc.github.io/2018/10/10/Generator/","excerpt":"Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。","text":"Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。 基本概念 Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。 1234567function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorldGenerator(); 上面代码定义了一个 Generator 函数helloWorldGenerator，它内部有两个yield表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。 然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象。 下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。 1234567891011hw.next()// &#123; value: 'hello', done: false &#125;hw.next()// &#123; value: 'world', done: false &#125;hw.next()// &#123; value: 'ending', done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; 总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。 ES6 没有规定，function关键字与函数名之间的星号，写在哪个位置。由于 Generator 函数仍然是普通函数，所以一般的写法是星号紧跟在function关键字后面。 yield 表达式 由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。 遍历器对象的next方法的运行逻辑如下。 （1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 （2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。 （3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。 （4）如果该函数没有return语句，则返回的对象的value属性值为undefined。 需要注意的是，yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。另外需要注意，yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。 next 方法 yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。 123456789101112function* f() &#123; for(var i = 0; true; i++) &#123; var reset = yield i; if(reset) &#123; i = -1; &#125; &#125;&#125;var g = f();g.next() // &#123; value: 0, done: false &#125;g.next() // &#123; value: 1, done: false &#125;g.next(true) // &#123; value: 0, done: false &#125; 上面代码先定义了一个可以无限运行的 Generator 函数f，如果next方法没有参数，每次运行到yield表达式，变量reset的值总是undefined。当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。 这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。 Generator.prototype.throw() Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。 12345678910111213141516171819var g = function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log('内部捕获', e); &#125;&#125;;var i = g();i.next();try &#123; i.throw('a'); i.throw('b');&#125; catch (e) &#123; console.log('外部捕获', e);&#125;// 内部捕获 a// 外部捕获 b 上面代码中，遍历器对象i连续抛出两个错误。第一个错误被 Generator 函数体内的catch语句捕获。i第二次抛出错误，由于 Generator 函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的catch语句捕获。 throw方法可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例。 Generator.prototype.return() Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数。 1234567891011function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return('foo') // &#123; value: \"foo\", done: true &#125;g.next() // &#123; value: undefined, done: true &#125; 如果 Generator 函数内部有try…finally代码块，那么return方法会推迟到finally代码块执行完再执行。 1234567891011121314151617function* numbers () &#123; yield 1; try &#123; yield 2; yield 3; &#125; finally &#123; yield 4; yield 5; &#125; yield 6;&#125;var g = numbers();g.next() // &#123; value: 1, done: false &#125;g.next() // &#123; value: 2, done: false &#125;g.return(7) // &#123; value: 4, done: false &#125;g.next() // &#123; value: 5, done: false &#125;g.next() // &#123; value: 7, done: true &#125; 上面代码中，调用return方法后，就开始执行finally代码块，然后等到finally代码块执行完，再执行return方法。 yield* 表达式 如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的。此时就需要用到yield*表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数。 123456789101112131415161718192021222324252627282930function* bar() &#123; yield 'x'; yield* foo(); yield 'y';&#125;// 等同于function* bar() &#123; yield 'x'; yield 'a'; yield 'b'; yield 'y';&#125;// 等同于function* bar() &#123; yield 'x'; for (let v of foo()) &#123; yield v; &#125; yield 'y';&#125;for (let v of bar())&#123; console.log(v);&#125;// \"x\"// \"a\"// \"b\"// \"y\"","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhangjichengcc.github.io/categories/笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"https://zhangjichengcc.github.io/tags/js/"},{"name":"ES6","slug":"ES6","permalink":"https://zhangjichengcc.github.io/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"https://zhangjichengcc.github.io/tags/前端/"}]},{"title":"js构造函数","slug":"js构造函数","date":"2018-10-09T08:53:48.000Z","updated":"2018-10-09T09:20:11.831Z","comments":true,"path":"2018/10/09/js构造函数/","link":"","permalink":"https://zhangjichengcc.github.io/2018/10/09/js构造函数/","excerpt":"前言：上篇文章（发布在我的segmentfault上）介绍了js中通过构造函数来实例化对象的各种方法js构造函数，这篇文章主要介绍构造函数的继承（类的继承），同样包括 ES5 和 ES6 两部分的介绍，能力所限，文中难免有不合理或错误的地方，还望批评指正~","text":"前言：上篇文章（发布在我的segmentfault上）介绍了js中通过构造函数来实例化对象的各种方法js构造函数，这篇文章主要介绍构造函数的继承（类的继承），同样包括 ES5 和 ES6 两部分的介绍，能力所限，文中难免有不合理或错误的地方，还望批评指正~ 原型首先简单介绍一下实例属性/方法 和 原型属性/方法，以便更好理解下文 123456789function Persion(name)&#123; this.name = name; // 属性 this.setName = function(nameName)&#123; // 实例方法 this.name = newName; &#125;&#125;Persion.prototype.sex = 'man'; // 向 Persion 原型中追加属性（原型方法）var persion = new Persion('zhang'); // 此时我们实例化一个persion对象，看一下name和sex有什么区别 通过 prototype 添加的属性将出现在实例对象的原型链中， 每个对象都会有一个内置 proto 对象，当在当前对象中找不到属性的时候就会在其原型链中查找（即原型链） 我们再来看下面的例子 注意：在构造函数中，一般很少有数组形式的引用属性，大部分情况都是：基本属性 + 方法。 1234567891011function Animal(n) &#123; // 声明一个构造函数 this.name = n; // 实例属性 this.arr = []; // 实例属性（引用类型） this.say = function()&#123; // 实例方法 return 'hello world'; &#125;&#125; Animal.prototype.sing = function() &#123; // 追加原型方法 return '吹呀吹呀，我的骄傲放纵~~';&#125;Animal.prototype.pArr = []; // 追加原型属性（引用类型） 接下来我们看一下实例属性/方法 和 原型属性/方法的区别 原型对象的用途是为每个实例对象存储共享的方法和属性，它仅仅是一个普通对象而已。并且所有的实例是共享同一个原型对象，因此有别于实例方法或属性，原型对象仅有一份。而实例有很多份，且实例属性和方法是独立的。 12345678910var cat = new Animal('cat'); // 实例化cat对象var dog = new Animal('dog'); // 实例化狗子对象cat.say === dog.say // false 不同的实例拥有不同的实例属性/方法cat.sing === dog.sing // true 不同的实例共享相同的原型属性/方法cat.arr.push('zz'); // 向cat实例对象的arr中追加元素；（私有）cat.pArr.push('xx'); // 向cat原型对象的pArr中追加元素；（共享）console.log(dog.arr); // 打印出 []，因为cat只改变了其私有的arrconsole.log(dog.pArr); // 打印出 ['xx'], 因为cat改变了与狗子（dog）共享的pArr 当然，原型属性为基本数据类型，则不会被共享在构造函数中：为了属性(实例基本属性)的私有性、以及方法(实例引用属性)的复用、共享。我们提倡：1、将属性封装在构造函数中2、将方法定义在原型对象上 ES5继承方式首先，我们定义一个Animal父类 1234567891011function Animal(n) &#123; this.name = n; // 实例属性 this.arr = []; // 实例属性（引用类型） this.say = function()&#123; // 实例方法 return 'hello world'; &#125;&#125;Animal.prototype.sing = function() &#123; // 追加原型方法 return '吹呀吹呀，我的骄傲放纵~~';&#125;Animal.prototype.pArr = []; // 追加原型属性（引用类型） 原型链继承12345678910function Cat(n) &#123; this.cName = n;&#125;Cat.prototype = new Animal(); // 父类的实例作为子类的原型对象var tom = new Cat('tom'); // 此时Tom拥有Cat和Animal的所有实例和原型方法/属性，实现了继承var black = new Cat('black');tom.arr.push('Im tom');console.log(black.arr); // 打印出 ['Im tom'], 结果其方法变成了共享的，而不是每个实例所私有的，这是因为父类的实例方法/属性变成了子类的原型方法/属性了； 优点: 实现了子对象对父对象的实例 方法/属性 和 原型方法/属性 的继承；缺点: 子类实例共享了父类构造函数的引用数据类型属性。 借用构造函数1234567891011function Cat(n) &#123; this.cName = n; Animal.call(this, this.cName); // 核心，把父类的实例方法属性指向子类&#125;var tom = new Cat('tom'); // 此时Tom拥有Cat和Animal的所有实例和原型方法/属性，实现了继承var black = new Cat('black');tom.arr.push('Im tom');console.log(black.arr); // 打印出 [], 其方法和属性是每个子类实例所私有的；tom.sing(); // undefind 无法继承父类的原型属性及方法； 优点:1、实现了子对象对父对象的实例 方法/属性 的继承，每个子类实例所继承的父类实例方法和属性都是其私有的；2、 创建子类实例，可以向父类构造函数传参数；缺点: 子类实例不能继承父类的构造属性和方法； 组合继承12345678910function Cat(n) &#123; this.cName = n; Animal.call(this, this.cName); // 核心，把父类的实例方法属性指向子类&#125;Cat.prototype = new Parent() // 核心, 父类的实例作为子类的原型对象Cat.prototype.constructor = Cat; // 修复子类Cat的构造器指向，防止原型链的混乱tom.arr.push('Im tom');console.log(black.arr); // 打印出 [], 其方法和属性是每个子类实例所私有的；tom.sing(); // 打印出 '吹呀吹呀，我的骄傲放纵~~'; 子类继承了父类的原型方法及属性 优点:1、创建子类实例，可以向父类构造函数传参数；2、父类的实例方法定义在父类的原型对象上，可以实现方法复用；3、不共享父类的构造方法及属性；缺点: 调用了2次父类的构造方法 寄生组合继承12345678910111213141516function Cat(n) &#123; this.cName = n; Animal.call(this, this.cName); // 核心，把父类的实例方法属性指向子类&#125;Cat.prototype = Parent.prototype; // 核心, 将父类原型赋值给子类原型（子类原型和父类原型，实质上是同一个）Cat.prototype.constructor = Cat; // 修复子类Cat的构造器指向，防止原型链的混乱tom.arr.push('Im tom');console.log(black.arr); // 打印出 [], 其方法和属性是每个子类实例所私有的；tom.sing(); // 打印出 '吹呀吹呀，我的骄傲放纵~~'; 子类继承了父类的原型方法及属性tom.pArr.push('publish'); // 修改继承于父类原型属性值 pArr;console.log(black.pArr); // 打印出 ['publish'], 父类的原型属性/方法 依旧是共享的，// 至此简直是完美呀~~~ 然鹅！Cat.prototype.childrenProp = '我是子类的原型属性！';var parent = new Animal('父类');console.log(parent.childrenProp); // 打印出'我是子类的原型属性！' what? 父类实例化的对象拥有子类的原型属性/方法，这是因为父类和子类使用了同一个原型 优点:1、创建子类实例，可以向父类构造函数传参数；2、子类的实例不共享父类的构造方法及属性；3、只调用了1次父类的构造方法；缺点: 父类和子类使用了同一个原型，导致子类的原型修改会影响父类； 寄生组合继承（简直完美）12345678910111213141516function Cat(n) &#123; this.cName = n; Animal.call(this, this.cName); // 核心，把父类的实例方法属性指向子类；&#125;var F = function()&#123;&#125;; // 核心，利用空对象作为中介；F.prototype = Parent.prototype; // 核心，将父类的原型赋值给空对象F；Cat.prototype = new F(); // 核心，将F的实例赋值给子类；Cat.prototype.constructor = Cat; // 修复子类Cat的构造器指向，防止原型链的混乱；tom.arr.push('Im tom');console.log(black.arr); // 打印出 [], 其方法和属性是每个子类实例所私有的；tom.sing(); // 打印出 '吹呀吹呀，我的骄傲放纵~~'; 子类继承了父类的原型方法及属性；tom.pArr.push('publish'); // 修改继承于父类原型属性值 pArr；console.log(black.pArr); // 打印出 ['publish'], 父类的原型属性/方法 依旧是共享的；Cat.prototype.childrenProp = '我是子类的原型属性！';var parent = new Animal('父类');console.log(parent.childrenProp); // undefind 父类实例化的对象不拥有子类的原型属性/方法； 优点: 完美实现继承；缺点:实现相对复杂 附YUI库实现继承123456789function extend(Child, Parent) &#123; var F = function()&#123;&#125;; F.prototype = Parent.prototype; hild.prototype = new F(); Child.prototype.constructor = Child; Child.uber = Parent.prototype; &#125;// 使用extend(Cat,Animal); Child.uber = Parent.prototype; 的意思是为子对象设一个uber属性，这个属性直接指向父对象的prototype属性。（uber是一个德语词，意思是”向上”、”上一层”。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。 ES6继承方式1234567891011121314151617class Animal&#123; // 父类 constructor(name)&#123; // 构造函数 this.name=name; &#125; eat()&#123; // 实例方法 return 'hello world'; &#125;&#125;class Cat extends Animal&#123; // 子类 constructor(name)&#123; super(name); // 调用实现父类的构造函数 this.pName = name; &#125; sing()&#123; return '吹呀吹呀，我的骄傲放纵~~'; &#125;&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhangjichengcc.github.io/categories/笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"https://zhangjichengcc.github.io/tags/js/"}]},{"title":"ES6 Promise","slug":"Promise","date":"2018-10-09T07:13:04.000Z","updated":"2018-11-29T07:23:10.703Z","comments":true,"path":"2018/10/09/Promise/","link":"","permalink":"https://zhangjichengcc.github.io/2018/10/09/Promise/","excerpt":"Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。","text":"Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 Promise 的含义 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise对象有以下两个特点。 （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 注意，为了行文方便，本章后面的resolved统一只指fulfilled状态，不包含rejected状态。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 如果某些事件不断地反复发生，一般来说，使用 Stream 模式是比部署 Promise 更好的选择。 基本用法 ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。 下面代码创造了一个Promise实例。 123456789const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 下面是一个Promise对象的简单例子。 123456789function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, 'done'); &#125;);&#125;timeout(100).then((value) =&gt; &#123; console.log(value);&#125;); 上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，就会触发then方法绑定的回调函数。 Promise 新建后就会立即执行。 1234567891011121314let promise = new Promise(function(resolve, reject) &#123; console.log('Promise'); resolve();&#125;);promise.then(function() &#123; console.log('resolved.');&#125;);console.log('Hi!');// Promise// Hi!// resolved 上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。 下面是异步加载图片的例子。 123456789101112131415function loadImageAsync(url) &#123; return new Promise(function(resolve, reject) &#123; const image = new Image(); image.onload = function() &#123; resolve(image); &#125;; image.onerror = function() &#123; reject(new Error('Could not load image at ' + url)); &#125;; image.src = url; &#125;);&#125; 上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。 下面是一个用Promise对象实现的 Ajax 操作的例子。 1234567891011121314151617181920212223242526272829const getJSON = function(url) &#123; const promise = new Promise(function(resolve, reject)&#123; const handler = function() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; const client = new XMLHttpRequest(); client.open(\"GET\", url); client.onreadystatechange = handler; client.responseType = \"json\"; client.setRequestHeader(\"Accept\", \"application/json\"); client.send(); &#125;); return promise;&#125;;getJSON(\"/posts.json\").then(function(json) &#123; console.log('Contents: ' + json);&#125;, function(error) &#123; console.error('出错了', error);&#125;); Promise.prototype.then() Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。 then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 12345getJSON(\"/posts.json\").then(function(json) &#123; return json.post;&#125;).then(function(post) &#123; // ...&#125;); 上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。 采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 1234567getJSON(\"/post/1.json\").then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function funcA(comments) &#123; console.log(\"resolved: \", comments);&#125;, function funcB(err)&#123; console.log(\"rejected: \", err);&#125;); 上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用funcA，如果状态变为rejected，就调用funcB。 如果采用箭头函数，上面的代码可以写得更简洁。 123456getJSON(\"/post/1.json\").then( post =&gt; getJSON(post.commentURL)).then( comments =&gt; console.log(\"resolved: \", comments), err =&gt; console.log(\"rejected: \", err)); Promise.prototype.catch() Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 123456getJSON('/posts.json').then(function(posts) &#123; // ...&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('发生错误！', error);&#125;); 上面代码中，getJSON方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。 1234567getJSON('/post/1.json').then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function(comments) &#123; // some code&#125;).catch(function(error) &#123; // 处理前面三个Promise产生的错误&#125;); 上面代码中，一共有三个 Promise 对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。 一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。 12345678910111213141516// badpromise .then(function(data) &#123; // success &#125;, function(err) &#123; // error &#125;);// goodpromise .then(function(data) &#123; //cb // success &#125;) .catch(function(err) &#123; // error &#125;); 上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。 Promise.prototype.finally() finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。 1234promise.then(result =&gt; &#123;···&#125;).catch(error =&gt; &#123;···&#125;).finally(() =&gt; &#123;···&#125;); 上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。 Promise.all() Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.all([p1, p2, p3]); 上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。） p的状态由p1、p2、p3决定，分成两种情况。 （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 下面是一个具体的例子。 12345678910// 生成一个Promise对象的数组const promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123; return getJSON('/post/' + id + \".json\");&#125;);Promise.all(promises).then(function (posts) &#123; // ...&#125;).catch(function(reason)&#123; // ...&#125;); 上面代码中，promises是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。 Promise.race() Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.race([p1, p2, p3]); 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。 下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve。 12345678910const p = Promise.race([ fetch('/resource-that-may-take-a-while'), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('request timeout')), 5000) &#125;)]);p.then(console.log).catch(console.error); 上面代码中，如果 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。 Promise.resolve() 有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用。 1const jsPromise = Promise.resolve($.ajax('/whatever.json')); 上面代码将 jQuery 生成的deferred对象，转为一个新的 Promise 对象。 Promise.resolve等价于下面的写法。 123Promise.resolve('foo')// 等价于new Promise(resolve =&gt; resolve('foo')) Promise.reject() Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。 12345678const p = Promise.reject('出错了');// 等同于const p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function (s) &#123; console.log(s)&#125;);// 出错了 上面代码生成一个 Promise 对象的实例p，状态为rejected，回调函数会立即执行。 注意，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。 1234567891011const thenable = &#123; then(resolve, reject) &#123; reject('出错了'); &#125;&#125;;Promise.reject(thenable).catch(e =&gt; &#123; console.log(e === thenable)&#125;)// true 上面代码中，Promise.reject方法的参数是一个thenable对象，执行以后，后面catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象。 Promise.try() 实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。 由于Promise.try为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用Promise.try包装一下。这样有许多好处，其中一点就是可以更好地管理异常。 事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。 123Promise.try(database.users.get(&#123;id: userId&#125;)) .then(...) .catch(...)","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhangjichengcc.github.io/categories/笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"https://zhangjichengcc.github.io/tags/js/"},{"name":"ES6","slug":"ES6","permalink":"https://zhangjichengcc.github.io/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"https://zhangjichengcc.github.io/tags/前端/"}]},{"title":"RISE - 巅峰造极境","slug":"RISE","date":"2018-09-29T02:49:14.000Z","updated":"2018-11-30T01:31:17.569Z","comments":true,"path":"2018/09/29/RISE/","link":"","permalink":"https://zhangjichengcc.github.io/2018/09/29/RISE/","excerpt":"2018 英雄联盟全球总决赛主题曲","text":"2018 英雄联盟全球总决赛主题曲 2018 英雄联盟全球总决赛主题曲","categories":[{"name":"娱乐","slug":"娱乐","permalink":"https://zhangjichengcc.github.io/categories/娱乐/"}],"tags":[{"name":"LOL","slug":"LOL","permalink":"https://zhangjichengcc.github.io/tags/LOL/"},{"name":"video","slug":"video","permalink":"https://zhangjichengcc.github.io/tags/video/"}]},{"title":"递归尾调用优化","slug":"递归尾调用优化","date":"2018-04-08T09:19:48.000Z","updated":"2018-11-30T01:14:03.374Z","comments":true,"path":"2018/04/08/递归尾调用优化/","link":"","permalink":"https://zhangjichengcc.github.io/2018/04/08/递归尾调用优化/","excerpt":"尾调用常用于函数递归的优化，递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误…","text":"尾调用常用于函数递归的优化，递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误… 什么是尾调用？ 尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。 123function f(x)&#123; return g(x);&#125; 上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。以下三种情况，都不属于尾调用。 123456789101112131415// 情况一function f(x)&#123; let y = g(x); return y;&#125;// 情况二function f(x)&#123; return g(x) + 1;&#125;// 情况三function f(x)&#123; g(x);&#125; 上面代码中情况一: 是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样;情况二: 属于调用后还有操作，即使写在一行内;情况三: 等同于下面的代码; 1234function f(x)&#123; g(x); return undefined;&#125; 尾调用不一定出现在函数尾部，只要是最后一步操作即可。 123456function f(x) &#123; if (x &gt; 0) &#123; return m(x) &#125; return n(x);&#125; 上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。 尾调用优化 尾调用之所以与其他调用不同，就在于它的特殊的调用位置。 我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。 123456789101112131415function f() &#123; let m = 1; let n = 2; return g(m + n);&#125;f();// 等同于function f() &#123; return g(3);&#125;f();// 等同于g(3); 上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。 这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。 注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。 1234567function addOne(a)&#123; var one = 1; function inner(b)&#123; return b + one; &#125; return inner(a);&#125; 上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。 尾递归 函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。 123456function factorial(n) &#123; if (n === 1) return 1; return n * factorial(n - 1);&#125;factorial(5) // 120 上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。 如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。 123456function factorial(n, total) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5, 1) // 120 还有一个比较著名的例子，就是计算 Fibonacci 数列，也能充分说明尾递归优化的重要性。非尾递归的 Fibonacci 数列实现如下。 123456789function Fibonacci (n) &#123; if ( n &lt;= 1 ) &#123;return 1&#125;; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;Fibonacci(10) // 89Fibonacci(100) // 堆栈溢出Fibonacci(500) // 堆栈溢出 尾递归优化过的 Fibonacci 数列实现如下。 123456789function Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123; if( n &lt;= 1 ) &#123;return ac2&#125;; return Fibonacci2 (n - 1, ac2, ac1 + ac2);&#125;Fibonacci2(100) // 573147844013817200000Fibonacci2(1000) // 7.0330367711422765e+208Fibonacci2(10000) // Infinity 附： 循环版 12345678910function Fibonacci3(n)&#123; if (n===1 || n===2) &#123; return 1; &#125; let ac1 = 1, ac2 = 1; for (let i = 2; i &lt; n; i++)&#123; [ac1, ac2] = [ac2, ac1 + ac2]; &#125; return ac2;&#125; 由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。 参考文献：[ECMAScript 6 入门 - 阮一峰][1][1]:http://es6.ruanyifeng.com/","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhangjichengcc.github.io/categories/笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"https://zhangjichengcc.github.io/tags/js/"},{"name":"ES6","slug":"ES6","permalink":"https://zhangjichengcc.github.io/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"https://zhangjichengcc.github.io/tags/前端/"},{"name":"算法","slug":"算法","permalink":"https://zhangjichengcc.github.io/tags/算法/"}]},{"title":"递归树结构解析","slug":"递归树结构解析","date":"2018-04-08T03:40:07.000Z","updated":"2018-12-06T02:52:35.771Z","comments":true,"path":"2018/04/08/递归树结构解析/","link":"","permalink":"https://zhangjichengcc.github.io/2018/04/08/递归树结构解析/","excerpt":"用递归的方式将树结构从根到叶子节点解析成数组","text":"用递归的方式将树结构从根到叶子节点解析成数组 从后台获取树结构的 json 数据，渲染成树图结构由于项目需求，需要将所有可行链路展示出来，于是采用递归方式将树结构解析为数组算法不算复杂，但用很多细节需要注意，很有价值，故记录下来以备以后查看 123456数据结构如下： 目标数组如下： a / \\ 1) [a, b, c] b e ==&gt;&gt; 2) [a, b, d] / \\ \\ 3) [a, e, f] c d f 1234567891011121314const obj = &#123; val: 'a', children: [ &#123; val: 'b', children: [ &#123; val: 'c', children: [] &#125;, &#123; val: 'd', children: [] &#125;, ], &#125;, &#123; val: 'e', children: [ &#123; val: 'f', &#125; ], &#125;, ],&#125;; 废话不多说，直接上代码1234567891011121314// 法一const initArr = (obj) =&gt; &#123; const newArr = []; // 定义空数组，用于每次遍历结束后存储结果 (function travel(item, arr)&#123; // 回调函数，立即执行 item为每次执行处理的对象，arr为叠加数组 if (item.children &amp;&amp; item.children.length) &#123; // 判断是否存在子元素，存在则遍历子元素递归调用 for (let i = 0; i &lt; item.children.length; i += 1) &#123; travel(item.children[i], arr.concat(item)); // 递归调用，并对数组 arr 进行叠加，注：此处不能用push，因此处是作为参数用来传递的，push 返回的是数组长度 &#125; &#125; else &#123; // 若不存在子元素，则一条链路遍历结束，将叠加数组添加到 newArr 中 newArr.push(arr.concat(item)); // 注意此处要记得将本次递归的 item 添加到arr中 &#125; &#125;(obj, [])); // 初始递归调用，此时的 item 为传入的树结构， 叠加数组arr为空 return newArr;&#125; 12345678910111213141516// 法二const initArr = (obj) =&gt; &#123; const newArr = []; (function travel(item, arr)&#123; const itemArr = [...arr]; // ES6 深拷贝数组，此处是让每次travel都有一个独立的itemArr, 防止公用全局arr叠加时造成污染 itemArr.push(item); // 由于 itemArr 为每次递归独立的叠加数组，故直接 push 改变数组本身即可 if (item.children &amp;&amp; item.children.length) &#123; for (let i in item.children) &#123; travel(data.children[i], itemArr); &#125; &#125; else &#123; newArr.push(itemArr); &#125; &#125;)(obj, []) return newArr;&#125; 结果如下图","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhangjichengcc.github.io/categories/笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"https://zhangjichengcc.github.io/tags/js/"},{"name":"前端","slug":"前端","permalink":"https://zhangjichengcc.github.io/tags/前端/"},{"name":"算法","slug":"算法","permalink":"https://zhangjichengcc.github.io/tags/算法/"}]},{"title":"给Hexo博客添加访问统计","slug":"给Hexo博客添加访问统计","date":"2018-03-20T08:35:58.000Z","updated":"2018-11-30T01:13:34.492Z","comments":true,"path":"2018/03/20/给Hexo博客添加访问统计/","link":"","permalink":"https://zhangjichengcc.github.io/2018/03/20/给Hexo博客添加访问统计/","excerpt":"导语： 引入不蒜子为你的博客添加访问量","text":"导语： 引入不蒜子为你的博客添加访问量 引入不蒜子1&lt;script async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; 这段代码可以写在footer.ejs里或者header.ejs里或者layout.ejs里 添加站点访问量通常站点的总访问量会显示在footer的位置，所以我们可以在footer.ejs里加上如下标签：123&lt;span id=\"busuanzi_container_site_uv\"&gt; 本站访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人次&lt;/span&gt; 计算访问量的方法有两种：算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。我用的是uv的方式，大家自行选择即可。 添加文章访问量文章的访问量显示在文章里面，所以在article.ejs里加上文章访问量的标签：123&lt;span id=\"busuanzi_container_page_pv\"&gt; 本文总阅读量&lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt;次&lt;/span&gt; 注意由于原有的『dn-lbstatics.qbox.me』域名过期，需把原有的：1&lt;script async src=\"\u0001\u0001//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\u0002\u0002\"&gt;&lt;/script&gt; 域名改为：1&lt;script async src=\"\u0001\u0001//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0002\u0002\"&gt;&lt;/script&gt; 参考 : 不蒜子","categories":[{"name":"工具","slug":"工具","permalink":"https://zhangjichengcc.github.io/categories/工具/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zhangjichengcc.github.io/tags/hexo/"}]},{"title":"hexo 创建文章 & 文章缩略图及banner & MarkDown","slug":"hexo-创建文章","date":"2018-02-27T06:29:09.000Z","updated":"2018-11-30T01:11:16.105Z","comments":true,"path":"2018/02/27/hexo-创建文章/","link":"","permalink":"https://zhangjichengcc.github.io/2018/02/27/hexo-创建文章/","excerpt":"hexo 文章的创建及markdown语法","text":"hexo 文章的创建及markdown语法 hexo 创建文章命令行输入：1$ hexo new \"new article\" 之后在source/_posts目录下面，多了一个new-article.md的文件。打开后：12345---title: new articledate: 2018-09-28 20:10:33tags:--- 文件的开头是属性，采用统一的yaml格式，用三条短横线分隔。下面是文章正文， 文章的正文支持markdown格式。新建、删除或修改文章后，不需要重启hexo server，刷新一下即可预览。 属性文章可以拥有如下属性： Setting Description Default layout layout post或page title 文章标题 文件名 date 创建日期 文件的创建日期 updated 修改日期 文件的修改日期 comments 是否开启评论 true tags 标签 NULL categories 分类 NULL permalink url中的名字 文件名 thumbnail 文章缩略图 NULL banner 文章缩略图&amp;文章首部banner NULL 分类和标签分类只有一个，但标签可以有多个且有两种写法如下： 12345678910---...categories: \"工具\"tags: - hexo - markdown - 前端# 或者# tags: [hexo, markdown, 前端]--- 文章缩略图和banner注： 不同主题设置可能不同，本部分只针icarus主题， 其他主题仅供参考当只设置 banner 时，文章的缩略图 和 banner 将都是 banner 所设置的图片；当只设置 thumbnail 时， 文章只有缩略图，无banner当同时设置 banner 和 thumbnail 时，banner 为 banner图，thumbnail 为缩略图， 两者各自生效； 设置图片前要在当前文章所在目录新建一个同名文件夹，用于存放图片等静态文件，如图； 或者修改配置文件_config.yml1post_asset_folder: true # 创建时生成静态资源文件夹 此时创建新文章时会自动在同级目录下生成同名文件夹用于存放静态文件，不同的主题可通过 thumbnail 和 banner 两个属性来设置缩略图和banner 文章缩略图设置：1234---...thumbnail: https://... # 此处为图片地址--- 文章banner设置：1234---...banner: https://... # 此处为图片地址--- 注： 若引用本地图片时，需要加上路径前缀，如下图： 则引用路径为： 1banner: /bolg/2018/09/27/hexo-创建文章/banner.jpg MarkDown 语法斜体和粗体1234*这是斜体* 或 _这也是斜体_ **这是粗体*****这是加粗斜体***~~这是删除线~~ 效果 这是斜体 或 这也是斜体这是粗体这是加粗斜体这是删除线 分级标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 超链接12345行内形式：[我的博客](https://zhangjichengcc.github.io/bolg/)参考形式：[我的博客][1]，有一个很好的平台-[GitHub][2][1]:https://kevinpu.github.io/[2]:http://www.jianshu.com/自动链接：我的博客地址&lt;https://zhangjichengcc.github.io/bolg/&gt; 效果 行内形式：我的博客参考形式：[我的博客][1]，有一个很好的平台-[GitHub][2][1]:https://zhangjichengcc.github.io/bolg/[2]:https://zhangjichengcc.github.io/自动链接：我的博客地址https://zhangjichengcc.github.io/bolg/ 列表无序列表：123* 无序列表项1+ 无序列表项2- 无序列表项3 效果 无序列表项1 无序列表项2 无序列表项3 有序列表1231.有序列表项12.有序列表项23.有序列表项3 效果 1.有序列表项12.有序列表项23.有序列表项3 插入图片1![文字说明](/images/...) 表格12345| 表头1|表头2|表头3|表头4|-| :- | :-: | -: ||默认左对齐|左对齐|居中对齐|右对齐||默认左对齐|左对齐|居中对齐|右对齐||默认左对齐|左对齐|居中对齐|右对齐| 效果 表头1 表头2 表头3 表头4 默认左对齐 左对齐 居中对齐 右对齐 默认左对齐 左对齐 居中对齐 右对齐 默认左对齐 左对齐 居中对齐 右对齐 code12``` bash...code 主体 效果 1...code 主体 引用1234&gt;这是引用这是引用这是引用&gt;&gt;不！我才是引用 效果 这是引用这是引用这是引用 不！我才是引用","categories":[{"name":"工具","slug":"工具","permalink":"https://zhangjichengcc.github.io/categories/工具/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://zhangjichengcc.github.io/tags/前端/"},{"name":"hexo","slug":"hexo","permalink":"https://zhangjichengcc.github.io/tags/hexo/"},{"name":"markdown","slug":"markdown","permalink":"https://zhangjichengcc.github.io/tags/markdown/"}]},{"title":"hexo常用指令","slug":"hexo常用指令","date":"2018-02-05T06:29:09.000Z","updated":"2018-11-29T10:41:22.881Z","comments":true,"path":"2018/02/05/hexo常用指令/","link":"","permalink":"https://zhangjichengcc.github.io/2018/02/05/hexo常用指令/","excerpt":"Welcome to Hexo!","text":"Welcome to Hexo! 开始使用 Install123$ npm install hexo -g # 安装 $ npm update hexo -g # 升级 $ hexo init # 初始化 快速开始 Quick Start启动本地服务（查看效果）1$ hexo server / $ hexo s 服务器设置1234$ hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。$ hexo server -s #静态模式$ hexo server -p 5000 #更改端口$ hexo server -i 192.168.1.1 #自定义 IP More info: Server 生成静态文件12$ hexo generate / $ hexo g #使用 Hexo 生成静态文件快速而且简单$ hexo generate --watch #监视文件变动 More info: Generating 文章发布hexo 支持在github等平台上一键发布 1$ hexo deploy / $ hexo d 清空缓存及静态文件1$ hexo clean 完成后部署12$ hexo generate --deploy / hexo g --d$ hexo deploy --generate / hexo d --g 创建模板 参数 描述 layout 布局 data 创建时间 title 标题 layout：参数 描述 存储路径 说明 post 文章（默认） source/_posts 可以直接发布 draft 草稿 source 在source下新建一个文件夹 page 页面 source/_drafts 新建文件将保存到 _drafts中 1$ hexo new [layout] &lt;title&gt; 创建文章12$ hexo new &lt;title&gt;$ hexo new \"postName\" #新建文章 创建页面12$ hexo new page &lt;pageName&gt;$ hexo new page \"pageName\" #新建页面 创建/发布草稿创建草稿会在source/_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到_drafts目录之中。 1$ hexo new draft \"new draft\" 如果你希望强行预览草稿，更改配置文件 (_config.yml)： 1render_drafts: true 或者，如下方式启动 server：1$ hexo server --drafts 发布草稿12$ hexo pushlish [layout] &lt;title&gt;$ hexo publish / $ hexo p More info: Writing 指令组合执行 &amp;通常开发测试要依次执行 hexo clean =&gt; hexo generate =&gt; hexo server, 我们可以通过指令组合执行来完成 1hexo clean &amp; hexo g &amp; hexo s More info: Deployment","categories":[{"name":"工具","slug":"工具","permalink":"https://zhangjichengcc.github.io/categories/工具/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zhangjichengcc.github.io/tags/hexo/"}]}]}